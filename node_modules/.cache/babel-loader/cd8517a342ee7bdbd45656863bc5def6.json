{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _ParagraphStyle = require('../models/ParagraphStyle');\n\nvar _ParagraphStyle2 = _interopRequireDefault(_ParagraphStyle);\n\nvar _Rect = require('../geom/Rect');\n\nvar _Rect2 = _interopRequireDefault(_Rect);\n\nvar _Block = require('../models/Block');\n\nvar _Block2 = _interopRequireDefault(_Block);\n\nvar _GlyphGenerator = require('./GlyphGenerator');\n\nvar _GlyphGenerator2 = _interopRequireDefault(_GlyphGenerator);\n\nvar _Typesetter = require('./Typesetter');\n\nvar _Typesetter2 = _interopRequireDefault(_Typesetter);\n\nvar _injectEngines = require('./injectEngines');\n\nvar _injectEngines2 = _interopRequireDefault(_injectEngines);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // 1. split into paragraphs\n// 2. get bidi runs and paragraph direction\n// 3. font substitution - map to resolved font runs\n// 4. script itemization\n// 5. font shaping - text to glyphs\n// 6. line breaking\n// 7. bidi reordering\n// 8. justification\n// 1. get a list of rectangles by intersecting path, line, and exclusion paths\n// 2. perform line breaking to get acceptable break points for each fragment\n// 3. ellipsize line if necessary\n// 4. bidi reordering\n// 5. justification\n\n/**\n * A LayoutEngine is the main object that performs text layout.\n * It accepts an AttributedString and a list of Container objects\n * to layout text into, and uses several helper objects to perform\n * various layout tasks. These objects can be overridden to customize\n * layout behavior.\n */\n\n\nvar LayoutEngine = function () {\n  function LayoutEngine(engines) {\n    (0, _classCallCheck3.default)(this, LayoutEngine);\n    var injectedEngines = (0, _injectEngines2.default)(engines);\n    this.glyphGenerator = new _GlyphGenerator2.default(injectedEngines);\n    this.typesetter = new _Typesetter2.default(injectedEngines);\n  }\n\n  LayoutEngine.prototype.layout = function layout(attributedString, containers) {\n    var start = 0;\n\n    for (var i = 0; i < containers.length && start < attributedString.length; i++) {\n      var container = containers[i];\n      var bbox = container.bbox,\n          columns = container.columns,\n          columnGap = container.columnGap;\n      var isLastContainer = i === containers.length - 1;\n      var columnWidth = (bbox.width - columnGap * (columns - 1)) / columns;\n      var rect = new _Rect2.default(bbox.minX, bbox.minY, columnWidth, bbox.height);\n\n      for (var j = 0; j < container.columns && start < attributedString.length; j++) {\n        start = this.layoutColumn(attributedString, start, container, rect.copy(), isLastContainer);\n        rect.x += columnWidth + container.columnGap;\n      }\n    }\n  };\n\n  LayoutEngine.prototype.layoutColumn = function layoutColumn(attributedString, start, container, rect, isLastContainer) {\n    while (start < attributedString.length && rect.height > 0) {\n      var next = attributedString.string.indexOf('\\n', start);\n      if (next === -1) next = attributedString.string.length;\n      var paragraph = attributedString.slice(start, next);\n      var block = this.layoutParagraph(paragraph, container, rect, start, isLastContainer);\n      var paragraphHeight = block.bbox.height + block.style.paragraphSpacing;\n      container.blocks.push(block);\n      rect.y += paragraphHeight;\n      rect.height -= paragraphHeight;\n      start += paragraph.length + 1; // If entire paragraph did not fit, move on to the next column or container.\n\n      if (start < next) break;\n    }\n\n    return start;\n  };\n\n  LayoutEngine.prototype.layoutParagraph = function layoutParagraph(attributedString, container, rect, stringOffset, isLastContainer) {\n    var _this = this;\n\n    var glyphString = this.glyphGenerator.generateGlyphs(attributedString);\n    var paragraphStyle = new _ParagraphStyle2.default(attributedString.runs[0].attributes);\n    var marginLeft = paragraphStyle.marginLeft,\n        marginRight = paragraphStyle.marginRight,\n        indent = paragraphStyle.indent,\n        maxLines = paragraphStyle.maxLines,\n        lineSpacing = paragraphStyle.lineSpacing;\n    var lineRect = new _Rect2.default(rect.x + marginLeft + indent, rect.y, rect.width - marginLeft - indent - marginRight, glyphString.height);\n    var pos = 0;\n    var lines = 0;\n    var firstLine = true;\n    var fragments = [];\n\n    while (lineRect.y < rect.maxY && pos < glyphString.length && lines < maxLines) {\n      var lineFragments = this.typesetter.layoutLineFragments(pos, lineRect, glyphString, container, paragraphStyle, stringOffset);\n      lineRect.y += lineRect.height + lineSpacing;\n\n      if (lineFragments.length > 0) {\n        fragments.push.apply(fragments, lineFragments);\n        pos = lineFragments[lineFragments.length - 1].end;\n        lines++;\n\n        if (firstLine) {\n          lineRect.x -= indent;\n          lineRect.width += indent;\n          firstLine = false;\n        }\n      }\n    } // Add empty line fragment for empty glyph strings\n\n\n    if (glyphString.length === 0) {\n      var newLineFragment = this.typesetter.layoutLineFragments(pos, lineRect, glyphString, container, paragraphStyle);\n      fragments.push.apply(fragments, newLineFragment);\n    }\n\n    var isTruncated = isLastContainer && pos < glyphString.length;\n    fragments.forEach(function (fragment, i) {\n      var isLastFragment = i === fragments.length - 1 && pos === glyphString.length;\n\n      _this.typesetter.finalizeLineFragment(fragment, paragraphStyle, isLastFragment, isTruncated);\n    });\n    return new _Block2.default(fragments, paragraphStyle);\n  };\n\n  return LayoutEngine;\n}();\n\nexports.default = LayoutEngine;","map":null,"metadata":{},"sourceType":"script"}