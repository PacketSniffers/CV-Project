{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * This class represents a numeric range between\n * a starting and ending value, inclusive.\n */\n\n\nvar Range = function () {\n  /**\n   * Creates a new Range\n   * @param {number} start the starting index of the range\n   * @param {number} end the ending index of the range, inclusive\n   */\n  function Range(start, end) {\n    (0, _classCallCheck3.default)(this, Range);\n    /**\n     * The starting index of the range\n     * @type {number}\n     */\n\n    this.start = start;\n    /**\n     * The ending index of the range, inclusive\n     * @type {number}\n     */\n\n    this.end = end;\n  }\n  /**\n   * The length of the range\n   * @type {number}\n   */\n\n  /**\n   * Returns whether this range is equal to the given range\n   * @param {Range} other the range to compare\n   * @return {boolean}\n   */\n\n\n  Range.prototype.equals = function equals(other) {\n    return other.start === this.start && other.end === this.end;\n  };\n  /**\n   * Returns a copy of the range\n   * @return {Range}\n   */\n\n\n  Range.prototype.copy = function copy() {\n    return new Range(this.start, this.end);\n  };\n  /**\n   * Returns whether the given value is in the range\n   * @param {number} index the index to check\n   * @return {boolean}\n   */\n\n\n  Range.prototype.contains = function contains(index) {\n    return index >= this.start && index <= this.end;\n  };\n  /**\n   * Extends the range to include the given index\n   * @param {number} index the index to ad\n   */\n\n\n  Range.prototype.extend = function extend(index) {\n    this.start = Math.min(this.start, index);\n    this.end = Math.max(this.end, index);\n  };\n  /**\n   * Merge intersecting ranges\n   * @param {number} ranges array of valid Range objects\n   * @return {array}\n   */\n\n\n  Range.merge = function merge(ranges) {\n    ranges.sort(function (a, b) {\n      return a.start - b.start;\n    });\n    var merged = [ranges[0]];\n\n    for (var i = 1; i < ranges.length; i++) {\n      var last = merged[merged.length - 1];\n      var next = ranges[i];\n\n      if (next.start <= last.end && next.end <= last.end) {\n        // Ignore this range completely.\n        // Next is contained inside last\n        continue;\n      } else if (next.start <= last.end) {\n        last.end = next.end;\n      } else {\n        merged.push(next);\n      }\n    }\n\n    return merged;\n  };\n\n  (0, _createClass3.default)(Range, [{\n    key: \"length\",\n    get: function get() {\n      return this.end - this.start + 1;\n    }\n  }]);\n  return Range;\n}();\n\nexports.default = Range;","map":null,"metadata":{},"sourceType":"script"}