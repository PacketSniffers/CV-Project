{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _iterator5 = require('babel-runtime/core-js/symbol/iterator');\n\nvar _iterator6 = _interopRequireDefault(_iterator5);\n\nvar _getIterator2 = require('babel-runtime/core-js/get-iterator');\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _set = require('babel-runtime/core-js/set');\n\nvar _set2 = _interopRequireDefault(_set);\n\nvar _unicodeProperties = require('@react-pdf/unicode-properties');\n\nvar _unicodeProperties2 = _interopRequireDefault(_unicodeProperties);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // https://www.w3.org/TR/css-text-3/#hanging-punctuation\n\n\nvar HANGING_PUNCTUATION_START_CATEGORIES = new _set2.default(['Ps', 'Pi', 'Pf']);\nvar HANGING_PUNCTUATION_END_CATEGORIES = new _set2.default(['Pe', 'Pi', 'Pf']);\nvar HANGING_PUNCTUATION_END_CODEPOINTS = new _set2.default([0x002c, // COMMA\n0x002e, // FULL STOP\n0x060c, // ARABIC COMMA\n0x06d4, // ARABIC FULL STOP\n0x3001, // IDEOGRAPHIC COMMA\n0x3002, // IDEOGRAPHIC FULL STOP\n0xff0c, // FULLWIDTH COMMA\n0xff0e, // FULLWIDTH FULL STOP\n0xfe50, // SMALL COMMA\n0xfe51, // SMALL IDEOGRAPHIC COMMA\n0xfe52, // SMALL FULL STOP\n0xff61, // HALFWIDTH IDEOGRAPHIC FULL STOP\n0xff64, // HALFWIDTH IDEOGRAPHIC COMMA\n0x002d // HYPHEN\n]);\n\nvar GlyphString = function () {\n  function GlyphString(string, glyphRuns, start, end) {\n    (0, _classCallCheck3.default)(this, GlyphString);\n    this.string = string;\n    this._glyphRuns = glyphRuns;\n    this.start = start || 0;\n    this._end = end;\n    this._glyphRunsCache = null;\n    this._glyphRunsCacheEnd = null;\n  }\n\n  GlyphString.prototype.slice = function slice(start, end) {\n    var stringStart = this.stringIndexForGlyphIndex(start);\n    var stringEnd = this.stringIndexForGlyphIndex(end);\n    return new GlyphString(this.string.slice(stringStart, stringEnd), this._glyphRuns, start + this.start, end + this.start);\n  };\n\n  GlyphString.prototype.runIndexAtGlyphIndex = function runIndexAtGlyphIndex(index) {\n    index += this.start;\n    var count = 0;\n\n    for (var i = 0; i < this._glyphRuns.length; i++) {\n      var run = this._glyphRuns[i];\n\n      if (count <= index && index < count + run.glyphs.length) {\n        return i;\n      }\n\n      count += run.glyphs.length;\n    }\n\n    return this._glyphRuns.length - 1;\n  };\n\n  GlyphString.prototype.runAtGlyphIndex = function runAtGlyphIndex(index) {\n    index += this.start;\n\n    for (var i = 0; i < this.glyphRuns.length; i++) {\n      var run = this.glyphRuns[i];\n\n      if (run.start <= index && run.end > index) {\n        return run;\n      }\n    }\n\n    return this.glyphRuns[this.glyphRuns.length - 1];\n  };\n\n  GlyphString.prototype.runIndexAtStringIndex = function runIndexAtStringIndex(index) {\n    var offset = 0;\n\n    for (var i = 0; i < this.glyphRuns.length; i++) {\n      var run = this.glyphRuns[i];\n\n      if (offset + run.stringStart <= index && offset + run.stringEnd >= index) {\n        return i;\n      }\n\n      offset += run.stringEnd;\n    }\n\n    return this._glyphRuns.length - 1;\n  };\n\n  GlyphString.prototype.runAtStringIndex = function runAtStringIndex(index) {\n    return this.glyphRuns[this.runIndexAtStringIndex(index)];\n  };\n\n  GlyphString.prototype.glyphAtIndex = function glyphAtIndex(index) {\n    var run = this.runAtGlyphIndex(index);\n    return run.glyphs[this.start + index - run.start];\n  };\n\n  GlyphString.prototype.positionAtIndex = function positionAtIndex(index) {\n    var run = void 0;\n    var count = 0;\n\n    for (var i = 0; i < this.glyphRuns.length; i++) {\n      run = this.glyphRuns[i];\n\n      if (count <= index && index < count + run.positions.length) {\n        return run.positions[index - count];\n      }\n\n      count += run.positions.length;\n    }\n\n    return run.positions[run.positions.length - 1];\n  };\n\n  GlyphString.prototype.getGlyphWidth = function getGlyphWidth(index) {\n    return this.positionAtIndex(index).xAdvance;\n  };\n\n  GlyphString.prototype.glyphIndexAtOffset = function glyphIndexAtOffset(width) {\n    var offset = 0;\n    var index = 0;\n\n    for (var _iterator = this.glyphRuns, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var run = _ref;\n\n      if (offset + run.advanceWidth > width) {\n        for (var _iterator2 = run.positions, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {\n          var _ref2;\n\n          if (_isArray2) {\n            if (_i2 >= _iterator2.length) break;\n            _ref2 = _iterator2[_i2++];\n          } else {\n            _i2 = _iterator2.next();\n            if (_i2.done) break;\n            _ref2 = _i2.value;\n          }\n\n          var position = _ref2;\n          var w = position.xAdvance;\n\n          if (offset + w > width) {\n            return index;\n          }\n\n          offset += w;\n          index++;\n        }\n      } else {\n        offset += run.advanceWidth;\n        index += run.glyphs.length;\n      }\n    }\n\n    return index;\n  };\n\n  GlyphString.prototype.stringIndexForGlyphIndex = function stringIndexForGlyphIndex(index) {\n    var run = void 0;\n    var count = 0;\n    var offset = 0;\n\n    for (var i = 0; i < this.glyphRuns.length; i++) {\n      run = this.glyphRuns[i];\n\n      if (offset <= index && offset + run.length > index) {\n        return count + run.stringIndices[index + this.start - run.start];\n      }\n\n      offset += run.length;\n      count += run.glyphIndices.length;\n    }\n\n    return count;\n  };\n\n  GlyphString.prototype.glyphIndexForStringIndex = function glyphIndexForStringIndex(index) {\n    var run = void 0;\n    var count = 0;\n    var offset = 0;\n\n    for (var i = 0; i < this.glyphRuns.length; i++) {\n      run = this.glyphRuns[i];\n\n      if (offset <= index && index < offset + run.stringEnd + 1) {\n        return count + run.glyphIndices[index - offset];\n      }\n\n      count += run.glyphs.length;\n      offset += run.stringEnd + 1;\n    }\n\n    return offset;\n  };\n\n  GlyphString.prototype.codePointAtGlyphIndex = function codePointAtGlyphIndex(glyphIndex) {\n    return this.string.codePointAt(this.stringIndexForGlyphIndex(glyphIndex));\n  };\n\n  GlyphString.prototype.charAtGlyphIndex = function charAtGlyphIndex(glyphIndex) {\n    return this.string.charAt(this.stringIndexForGlyphIndex(glyphIndex));\n  };\n\n  GlyphString.prototype.offsetAtGlyphIndex = function offsetAtGlyphIndex(glyphIndex) {\n    var offset = 0;\n    var count = glyphIndex;\n\n    for (var _iterator3 = this.glyphRuns, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var run = _ref3;\n\n      for (var i = 0; i < run.glyphs.length; i++) {\n        if (count === 0) {\n          return offset;\n        }\n\n        offset += run.positions[i].xAdvance;\n        count -= 1;\n      }\n    }\n\n    return offset;\n  };\n\n  GlyphString.prototype.indexOf = function indexOf(string) {\n    var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var stringIndex = this.stringIndexForGlyphIndex(index);\n    var nextIndex = this.string.indexOf(string, stringIndex);\n\n    if (nextIndex === -1) {\n      return -1;\n    }\n\n    return this.glyphIndexForStringIndex(nextIndex);\n  };\n\n  GlyphString.prototype.getUnicodeCategory = function getUnicodeCategory(index) {\n    var codePoint = this.codePointAtGlyphIndex(index);\n    return codePoint ? _unicodeProperties2.default.getCategory(codePoint) : null;\n  };\n\n  GlyphString.prototype.isWhiteSpace = function isWhiteSpace(index) {\n    var codePoint = this.codePointAtGlyphIndex(index);\n    return codePoint ? _unicodeProperties2.default.isWhiteSpace(codePoint) : false;\n  };\n\n  GlyphString.prototype.isHangingPunctuationStart = function isHangingPunctuationStart(index) {\n    return HANGING_PUNCTUATION_START_CATEGORIES.has(this.getUnicodeCategory(index));\n  };\n\n  GlyphString.prototype.isHangingPunctuationEnd = function isHangingPunctuationEnd(index) {\n    return HANGING_PUNCTUATION_END_CATEGORIES.has(this.getUnicodeCategory(index)) || HANGING_PUNCTUATION_END_CODEPOINTS.has(this.codePointAtGlyphIndex(index));\n  };\n\n  GlyphString.prototype.insertGlyph = function insertGlyph(index, codePoint) {\n    var runIndex = this.runIndexAtGlyphIndex(index);\n    var run = this._glyphRuns[runIndex];\n    var _run$attributes = run.attributes,\n        font = _run$attributes.font,\n        fontSize = _run$attributes.fontSize;\n    var glyph = run.attributes.font.glyphForCodePoint(codePoint);\n    var scale = fontSize / font.unitsPerEm;\n    var glyphIndex = this.start + index - run.start;\n\n    if (this._end) {\n      this._end += 1;\n    }\n\n    run.glyphs.splice(glyphIndex, 0, glyph);\n    run.stringIndices.splice(glyphIndex, 0, run.stringIndices[glyphIndex]);\n\n    for (var i = 0; i < run.glyphIndices.length; i++) {\n      if (run.glyphIndices[i] >= glyphIndex) {\n        run.glyphIndices[i] += 1;\n      }\n    }\n\n    run.positions.splice(glyphIndex, 0, {\n      xAdvance: glyph.advanceWidth * scale,\n      yAdvance: 0,\n      xOffset: 0,\n      yOffset: run.attributes.yOffset * font.unitsPerEm\n    });\n    run.end += 1;\n\n    for (var _i4 = runIndex + 1; _i4 < this._glyphRuns.length; _i4++) {\n      this._glyphRuns[_i4].start += 1;\n      this._glyphRuns[_i4].end += 1;\n    }\n\n    this._glyphRunsCache = null;\n  };\n\n  GlyphString.prototype.deleteGlyph = function deleteGlyph(index) {\n    if (index < 0 || index >= this.length) {\n      return;\n    }\n\n    var runIndex = this.runIndexAtGlyphIndex(index);\n    var run = this._glyphRuns[runIndex];\n    var glyphIndex = this.start + index - run.start;\n    run.glyphs.splice(glyphIndex, 1);\n    run.positions.splice(glyphIndex, 1);\n    run.stringIndices.splice(glyphIndex, 1);\n\n    for (var i = 0; i < run.glyphIndices.length; i++) {\n      if (run.glyphIndices[i] >= glyphIndex) {\n        run.glyphIndices[i] -= 1;\n      }\n    }\n\n    run.end--;\n\n    for (var _i5 = runIndex + 1; _i5 < this._glyphRuns.length; _i5++) {\n      this._glyphRuns[_i5].start--;\n      this._glyphRuns[_i5].end--;\n    }\n\n    this._glyphRunsCache = null;\n  };\n\n  GlyphString.prototype[_iterator6.default] =\n  /*#__PURE__*/\n  _regenerator2.default.mark(function _callee() {\n    var x, _iterator4, _isArray4, _i6, _ref4, run, i;\n\n    return _regenerator2.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            x = 0;\n            _iterator4 = this.glyphRuns, _isArray4 = Array.isArray(_iterator4), _i6 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);\n\n          case 2:\n            if (!_isArray4) {\n              _context.next = 8;\n              break;\n            }\n\n            if (!(_i6 >= _iterator4.length)) {\n              _context.next = 5;\n              break;\n            }\n\n            return _context.abrupt('break', 23);\n\n          case 5:\n            _ref4 = _iterator4[_i6++];\n            _context.next = 12;\n            break;\n\n          case 8:\n            _i6 = _iterator4.next();\n\n            if (!_i6.done) {\n              _context.next = 11;\n              break;\n            }\n\n            return _context.abrupt('break', 23);\n\n          case 11:\n            _ref4 = _i6.value;\n\n          case 12:\n            run = _ref4;\n            i = 0;\n\n          case 14:\n            if (!(i < run.glyphs.length)) {\n              _context.next = 21;\n              break;\n            }\n\n            _context.next = 17;\n            return {\n              glyph: run.glyphs[i],\n              position: run.positions[i],\n              run: run,\n              x: x,\n              index: run.start + i\n            };\n\n          case 17:\n            x += run.positions[i].xAdvance;\n\n          case 18:\n            i++;\n            _context.next = 14;\n            break;\n\n          case 21:\n            _context.next = 2;\n            break;\n\n          case 23:\n          case 'end':\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  });\n  (0, _createClass3.default)(GlyphString, [{\n    key: 'end',\n    get: function get() {\n      if (this._glyphRuns.length === 0) {\n        return 0;\n      }\n\n      var glyphEnd = this._glyphRuns[this._glyphRuns.length - 1].end;\n\n      if (this._end) {\n        return Math.min(this._end, glyphEnd);\n      }\n\n      return this._glyphRuns.length > 0 ? glyphEnd : 0;\n    }\n  }, {\n    key: 'length',\n    get: function get() {\n      return this.end - this.start;\n    }\n  }, {\n    key: 'advanceWidth',\n    get: function get() {\n      return this.glyphRuns.reduce(function (acc, run) {\n        return acc + run.advanceWidth;\n      }, 0);\n    }\n  }, {\n    key: 'height',\n    get: function get() {\n      return this.glyphRuns.reduce(function (acc, run) {\n        return Math.max(acc, run.height);\n      }, 0);\n    }\n  }, {\n    key: 'ascent',\n    get: function get() {\n      return this.glyphRuns.reduce(function (acc, run) {\n        return Math.max(acc, run.ascent);\n      }, 0);\n    }\n  }, {\n    key: 'descent',\n    get: function get() {\n      return this.glyphRuns.reduce(function (acc, run) {\n        return Math.min(acc, run.descent);\n      }, 0);\n    }\n  }, {\n    key: 'glyphRuns',\n    get: function get() {\n      if (this._glyphRunsCache && this._glyphRunsCacheEnd === this.end) {\n        return this._glyphRunsCache;\n      }\n\n      if (this._glyphRuns.length === 0) {\n        this._glyphRunsCache = [];\n        this._glyphRunsCacheEnd = this.end;\n        return [];\n      }\n\n      var startRunIndex = this.runIndexAtGlyphIndex(0);\n      var endRunIndex = this.runIndexAtGlyphIndex(this.length);\n      var startRun = this._glyphRuns[startRunIndex];\n      var endRun = this._glyphRuns[endRunIndex];\n      var runs = [];\n      runs.push(startRun.slice(this.start - startRun.start, this.end - startRun.start));\n\n      if (endRunIndex !== startRunIndex) {\n        runs.push.apply(runs, this._glyphRuns.slice(startRunIndex + 1, endRunIndex));\n\n        if (this.end - endRun.start !== 0) {\n          runs.push(endRun.slice(0, this.end - endRun.start));\n        }\n      }\n\n      this._glyphRunsCache = runs;\n      this._glyphRunsCacheEnd = this.end;\n      return runs;\n    }\n  }]);\n  return GlyphString;\n}();\n\nexports.default = GlyphString;","map":null,"metadata":{},"sourceType":"script"}