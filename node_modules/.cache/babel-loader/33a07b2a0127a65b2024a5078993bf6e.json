{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _getIterator2 = require('babel-runtime/core-js/get-iterator');\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _LineFragment = require('../models/LineFragment');\n\nvar _LineFragment2 = _interopRequireDefault(_LineFragment);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar ALIGNMENT_FACTORS = {\n  left: 0,\n  center: 0.5,\n  right: 1,\n  justify: 0\n};\n/**\n * A Typesetter performs glyph line layout, including line breaking,\n * hyphenation, justification, truncation, hanging punctuation,\n * and text decoration. It uses several underlying objects to perform\n * these tasks, which could be overridden in order to customize the\n * typesetter's behavior.\n */\n\nvar Typesetter = function () {\n  function Typesetter() {\n    var engines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    (0, _classCallCheck3.default)(this, Typesetter);\n    this.lineBreaker = engines.lineBreaker;\n    this.lineFragmentGenerator = engines.lineFragmentGenerator;\n    this.justificationEngine = engines.justificationEngine;\n    this.truncationEngine = engines.truncationEngine;\n    this.decorationEngine = engines.decorationEngine;\n    this.tabEngine = engines.tabEngine;\n  }\n\n  Typesetter.prototype.layoutLineFragments = function layoutLineFragments(start, lineRect, glyphString, container, paragraphStyle, stringOffset) {\n    var lineString = glyphString.slice(start, glyphString.length); // Guess the line height using the full line before intersecting with the container.\n\n    lineRect.height = lineString.slice(0, lineString.glyphIndexAtOffset(lineRect.width)).height; // Generate line fragment rectangles by intersecting with the container.\n\n    var fragmentRects = this.lineFragmentGenerator.generateFragments(lineRect, container);\n    if (fragmentRects.length === 0) return [];\n    var pos = 0;\n    var lineFragments = [];\n    var lineHeight = paragraphStyle.lineHeight;\n\n    for (var _iterator = fragmentRects, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var fragmentRect = _ref;\n      var line = lineString.slice(pos, lineString.length);\n\n      if (this.tabEngine) {\n        this.tabEngine.processLineFragment(line, container);\n      }\n\n      var bk = this.lineBreaker.suggestLineBreak(line, fragmentRect.width, paragraphStyle);\n\n      if (bk) {\n        bk.position += pos;\n        var lineFragment = new _LineFragment2.default(fragmentRect, lineString.slice(pos, bk.position));\n        lineFragment.stringStart = stringOffset + glyphString.stringIndexForGlyphIndex(lineFragment.start);\n        lineFragment.stringEnd = stringOffset + glyphString.stringIndexForGlyphIndex(lineFragment.end);\n        lineFragments.push(lineFragment);\n        lineHeight = Math.max(lineHeight, lineFragment.height);\n        pos = bk.position;\n\n        if (pos >= lineString.length) {\n          break;\n        }\n      }\n    } // Update the fragments on this line with the computed line height\n\n\n    if (lineHeight !== 0) lineRect.height = lineHeight;\n\n    for (var _iterator2 = lineFragments, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var fragment = _ref2;\n      fragment.rect.height = lineHeight;\n    }\n\n    return lineFragments;\n  };\n\n  Typesetter.prototype.finalizeLineFragment = function finalizeLineFragment(lineFragment, paragraphStyle, isLastFragment, isTruncated) {\n    var align = isLastFragment && !isTruncated ? paragraphStyle.alignLastLine : paragraphStyle.align;\n\n    if (isLastFragment && isTruncated && paragraphStyle.truncationMode) {\n      this.truncationEngine.truncate(lineFragment, paragraphStyle.truncationMode);\n    }\n\n    this.adjustLineFragmentRectangle(lineFragment, paragraphStyle, align);\n\n    if (align === 'justify' || lineFragment.advanceWidth > lineFragment.rect.width) {\n      this.justificationEngine.justify(lineFragment, {\n        factor: paragraphStyle.justificationFactor\n      });\n    }\n\n    this.decorationEngine.createDecorationLines(lineFragment);\n  };\n\n  Typesetter.prototype.adjustLineFragmentRectangle = function adjustLineFragmentRectangle(lineFragment, paragraphStyle, align) {\n    var start = 0;\n    var end = lineFragment.length; // Ignore whitespace at the start and end of a line for alignment\n\n    while (lineFragment.isWhiteSpace(start)) {\n      lineFragment.overflowLeft += lineFragment.getGlyphWidth(start++);\n    }\n\n    while (lineFragment.isWhiteSpace(end - 1)) {\n      lineFragment.overflowRight += lineFragment.getGlyphWidth(--end);\n    } // Adjust line rect for hanging punctuation\n\n\n    if (paragraphStyle.hangingPunctuation) {\n      if (align === 'left' || align === 'justify') {\n        if (lineFragment.isHangingPunctuationStart(start)) {\n          lineFragment.overflowLeft += lineFragment.getGlyphWidth(start++);\n        }\n      }\n\n      if (align === 'right' || align === 'justify') {\n        if (lineFragment.isHangingPunctuationEnd(end - 1)) {\n          lineFragment.overflowRight += lineFragment.getGlyphWidth(--end);\n        }\n      }\n    }\n\n    lineFragment.rect.x -= lineFragment.overflowLeft;\n    lineFragment.rect.width += lineFragment.overflowLeft + lineFragment.overflowRight; // Adjust line offset for alignment\n\n    var remainingWidth = lineFragment.rect.width - lineFragment.advanceWidth;\n    lineFragment.rect.x += remainingWidth * ALIGNMENT_FACTORS[align];\n  };\n\n  return Typesetter;\n}();\n\nexports.default = Typesetter;","map":null,"metadata":{},"sourceType":"script"}