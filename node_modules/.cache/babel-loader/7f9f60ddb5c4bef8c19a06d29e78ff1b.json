{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _getIterator2 = require('babel-runtime/core-js/get-iterator');\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _linebreak = require('linebreak');\n\nvar _linebreak2 = _interopRequireDefault(_linebreak);\n\nvar _hypher = require('hypher');\n\nvar _hypher2 = _interopRequireDefault(_hypher);\n\nvar _hyphenation = require('hyphenation.en-us');\n\nvar _hyphenation2 = _interopRequireDefault(_hyphenation);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar hyphenator = new _hypher2.default(_hyphenation2.default);\nvar HYPHEN = 0x002d;\nvar SHRINK_FACTOR = 0.04;\n/**\n * A LineBreaker is used by the Typesetter to perform\n * Unicode line breaking and hyphenation.\n */\n\nexports.default = function () {\n  return function () {\n    return function () {\n      function LineBreaker() {\n        (0, _classCallCheck3.default)(this, LineBreaker);\n      }\n\n      LineBreaker.prototype.suggestLineBreak = function suggestLineBreak(glyphString, width, paragraphStyle) {\n        var hyphenationFactor = paragraphStyle.hyphenationFactor || 0;\n        var glyphIndex = glyphString.glyphIndexAtOffset(width);\n        if (glyphIndex === -1) return null;\n\n        if (glyphIndex === glyphString.length) {\n          return {\n            position: glyphString.length,\n            required: true\n          };\n        }\n\n        var stringIndex = glyphString.stringIndexForGlyphIndex(glyphIndex);\n        var bk = this.findBreakPreceeding(glyphString.string, stringIndex);\n\n        if (bk) {\n          var breakIndex = glyphString.glyphIndexForStringIndex(bk.position);\n\n          if (bk.next != null && this.shouldHyphenate(glyphString, breakIndex, width, hyphenationFactor)) {\n            var lineWidth = glyphString.offsetAtGlyphIndex(glyphIndex);\n            var shrunk = lineWidth + lineWidth * SHRINK_FACTOR;\n            var shrunkIndex = glyphString.glyphIndexAtOffset(shrunk);\n            stringIndex = Math.min(bk.next, glyphString.stringIndexForGlyphIndex(shrunkIndex));\n            var point = this.findHyphenationPoint(glyphString.string.slice(bk.position, bk.next), stringIndex - bk.position);\n\n            if (point > 0) {\n              bk.position += point;\n              breakIndex = glyphString.glyphIndexForStringIndex(bk.position);\n\n              if (bk.position < bk.next) {\n                glyphString.insertGlyph(breakIndex++, HYPHEN);\n              }\n            }\n          }\n\n          bk.position = breakIndex;\n        }\n\n        return bk;\n      };\n\n      LineBreaker.prototype.findBreakPreceeding = function findBreakPreceeding(string, index) {\n        var breaker = new _linebreak2.default(string);\n        var last = null;\n        var bk = null;\n\n        while (bk = breaker.nextBreak()) {\n          // console.log(bk);\n          if (bk.position > index) {\n            if (last) {\n              last.next = bk.position;\n            }\n\n            return last;\n          }\n\n          if (bk.required) {\n            return bk;\n          }\n\n          last = bk;\n        }\n\n        return null;\n      };\n\n      LineBreaker.prototype.shouldHyphenate = function shouldHyphenate(glyphString, glyphIndex, width, hyphenationFactor) {\n        var lineWidth = glyphString.offsetAtGlyphIndex(glyphIndex);\n        return lineWidth / width < hyphenationFactor;\n      };\n\n      LineBreaker.prototype.findHyphenationPoint = function findHyphenationPoint(string, index) {\n        var parts = hyphenator.hyphenate(string);\n        var count = 0;\n\n        for (var _iterator = parts, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n          var _ref;\n\n          if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref = _iterator[_i++];\n          } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref = _i.value;\n          }\n\n          var part = _ref;\n\n          if (count + part.length > index) {\n            break;\n          }\n\n          count += part.length;\n        }\n\n        return count;\n      };\n\n      return LineBreaker;\n    }();\n  };\n};","map":null,"metadata":{},"sourceType":"script"}